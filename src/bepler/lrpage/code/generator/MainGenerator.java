package bepler.lrpage.code.generator;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;
import java.util.Set;

import bepler.lrpage.code.generator.parser.ParserGenerator;

import com.sun.codemodel.JBlock;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JForLoop;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JType;
import com.sun.codemodel.JVar;
import com.sun.codemodel.JWhileLoop;

public class MainGenerator {
	
	private static final String MAIN = "Main";
	private static final String PRINT_VISITOR = "PrintVisitor";
	private static final String DEFAULT_ERROR_HANDLER = "DefaultParserErrorHandler";
	
	/**
	 * Generates a main class with main method for testing the generated parser and lexer
	 * from the command line.
	 * @param pckg - package in which to place the main class
	 * @param model - JCodeModel
	 * @param lexer - the lexer JDefinedClass
	 * @param parser - the parser JDefinedClass
	 * @param printVisitor - the print visitor JDefinedClass - this is used to print
	 * the AST generated by the parser
	 * @param abstractNode - the synatx node interface
	 * @throws JClassAlreadyExistsException
	 * 
	 * @author Tristan Bepler
	 */
	public static void generateMain(String pckg, JCodeModel model,
			JDefinedClass lexer, ParserGenerator parseGen, JDefinedClass printVisitor,
			JDefinedClass abstractNode)
			throws JClassAlreadyExistsException{
		String name = pckg == null ? MAIN : pckg+"."+MAIN;
		JDefinedClass mainClass = model._class(name);
		CodeGenerator.appendJDocHeader(mainClass);
		JMethod main = mainClass.method(JMod.PUBLIC + JMod.STATIC, void.class, "main");
		main._throws(IOException.class);
		main._throws(parseGen.getParsingExceptionClass());
		main.param(String[].class, "args");
		JBlock body = main.body();
		JVar visitor = body.decl(printVisitor, "visitor", JExpr._new(printVisitor));
		JVar parse = body.decl(parseGen.getParserClass(), "parser", JExpr._new(parseGen.getParserClass()));
		JDefinedClass errorHandlerClass = generateDefaultExceptionHandler(pckg, model, parseGen);
		JVar errorHandler = body.decl(errorHandlerClass, "errorHandler", JExpr._new(errorHandlerClass));
		JVar str = body.decl(model.ref(String.class), "line");
		body.decl(model.ref(BufferedReader.class), "reader", JExpr._new(model.ref(BufferedReader.class))
				.arg(JExpr._new(model.ref(InputStreamReader.class)).arg(model.ref(System.class).staticRef("in"))));
		JWhileLoop loop = body._while(JExpr.direct("(line = reader.readLine()) != null"));
		loop.body()._if(JExpr.invoke(str, "equals").arg(JExpr.lit("q")))._then()._break();
		JVar lex = loop.body().decl(lexer, "lexer", JExpr._new(lexer).arg(str));
		loop.body()._while(JExpr.invoke(lex, "hasNext")).body()
			.invoke(model.ref(System.class).staticRef("out"), "print").arg(JExpr.invoke(lex, "nextToken").plus(JExpr.lit(" ")));
		loop.body().invoke(model.ref(System.class).staticRef("out"), "println");
		loop.body().assign(lex, JExpr._new(lexer).arg(str));
		JVar node = loop.body().decl(abstractNode, "tree", JExpr.invoke(parse, "parse").arg(lex).arg(errorHandler));
		loop.body()._if(node.ne(JExpr._null()))._then().invoke(node, "accept").arg(visitor);
		
	}
	
	private static JDefinedClass generateDefaultExceptionHandler(
			String pckg, JCodeModel model, ParserGenerator parseGen)
					throws JClassAlreadyExistsException{
		String name = pckg == null ? DEFAULT_ERROR_HANDLER : pckg + "." + DEFAULT_ERROR_HANDLER;
		JDefinedClass clazz = model._class(name);
		CodeGenerator.appendJDocHeader(clazz);
		clazz._implements(parseGen.getExceptionHandlerInterface());
		
		//define the proceed method to print the exception message and return true
		JMethod proceed = clazz.method(JMod.PUBLIC, boolean.class, ParserGenerator.PROCEED_METHOD);
		JVar excep = proceed.param(parseGen.getParsingExceptionClass(), "e");
		proceed.annotate(Override.class);
		proceed.body().invoke(model.ref(System.class).staticRef("err"), "println")
			.arg(JExpr.invoke(excep, "getMessage"));
		proceed.body()._return(JExpr.TRUE);
		
		return clazz;
	}
	
	/**
	 * Generates a Visitor implementation that traverses the abstract syntax tree
	 * and prints its structure.
	 * @param pckg - package in which to create this class
	 * @param model - JCodeModel
	 * @param iVisitor - the JDefinedClass for the visitor interface
	 * @param terminals - a set containing the JDefinedClass objects for the
	 * terminal nodes
	 * @return - the generated visitor implementation
	 * @throws JClassAlreadyExistsException
	 * 
	 * @author Tristan Bepler
	 */
	public static JDefinedClass generatePrintVisitor(String pckg, JCodeModel model,
			JDefinedClass iVisitor, Set<JDefinedClass> terminals)
			throws JClassAlreadyExistsException{
		String name = pckg == null ? PRINT_VISITOR : pckg + "." + PRINT_VISITOR;
		JDefinedClass printVisitor = model._class(name);
		CodeGenerator.appendJDocHeader(printVisitor);
		printVisitor._implements(iVisitor);
		//add a field for the delimiter string
		JVar delim = printVisitor.field(JMod.PRIVATE+JMod.STATIC+JMod.FINAL, String.class, "DELIM", JExpr.lit("  "));
		//add a field for the current depth
		JVar depth = printVisitor.field(JMod.PRIVATE, int.class, "depth", JExpr.lit(0));
		//add a print method which prints an object with the proper indentation
		JMethod print = definePrintMethod(model, printVisitor, delim, depth);
		
		for(JMethod method : iVisitor.methods()){
			JDefinedClass paramType = getParameterClass(method);
			//declare this method in the print visitor
			JMethod def = printVisitor.method(JMod.PUBLIC, void.class, method.name());
			def.annotate(Override.class);
			JVar param = def.param(paramType, "node");
			//print this node
			def.body().invoke(JExpr._this(), print).arg(param);
			if(!terminals.contains(paramType)){
				//the param is not a terminal, so traverse its children
				defineChildNodeTraversal(param, depth, print, paramType, def);
			}
		}
		
		return printVisitor;
	}
	
	/**
	 * Defines the traversal of this node's children
	 * @param depth
	 * @param print
	 * @param paramType
	 * @param def
	 * 
	 * @author Tristan Bepler
	 */
	private static void defineChildNodeTraversal(JVar param, JVar depth, JMethod print,
			JDefinedClass paramType, JMethod def) {
		//increment the depth and traverse the children
		def.body().invoke(JExpr._this(), print).arg(JExpr.lit("{"));
		//increment the depth
		def.body().assign(depth, depth.plus(JExpr.lit(1)));
		for(JVar field : paramType.fields().values()){
			//if the field is a JDefinedClass, traverse it
			if(field.type() instanceof JDefinedClass){
				def.body().invoke(JExpr.ref(param, field), "accept").arg(JExpr._this());
			}
		}
		//decrement the depth
		def.body().assign(depth, depth.minus(JExpr.lit(1)));
		def.body().invoke(JExpr._this(), print).arg(JExpr.lit("}"));
	}
	
	/**
	 * Defines the print visitor's print method, which prints an object
	 * with the appropriate indentation.
	 * @param model
	 * @param printVisitor
	 * @param delim
	 * @param depth
	 * @return
	 * 
	 * @author Tristan Bepler
	 */
	private static JMethod definePrintMethod(JCodeModel model,
			JDefinedClass printVisitor, JVar delim, JVar depth) {
		JMethod print = printVisitor.method(JMod.PRIVATE, void.class, "print");
		JVar obj = print.param(Object.class, "obj");
		JForLoop loop = print.body()._for();
		JVar i = loop.init(model.INT, "i", JExpr.lit(0));
		loop.test(i.lt(depth));
		loop.update(i.incr());
		loop.body().invoke(model.ref(System.class).staticRef("out"), "print").arg(delim);
		print.body().invoke(model.ref(System.class).staticRef("out"), "println").arg(obj);
		return print;
	}
	
	/**
	 * Extracts the JDefinedClass of the method's parameter. Asserts
	 * that the method only takes one parameter and that that
	 * parameter type is a JDefinedClass.
	 * @param method
	 * @return
	 * 
	 * @author Tristan Bepler
	 */
	private static JDefinedClass getParameterClass(JMethod method){
		List<JVar> params = method.params();
		//each visit method should take exactly one parameter
		assert(params.size() == 1);
		JVar param = params.get(0);
		JType type = param.type();
		//the type must be an instance of JClass
		assert(type instanceof JDefinedClass);
		return (JDefinedClass) type;
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
}
