
package bepler.lrpage.ebnf.parser;

import java.util.regex.Pattern;
import bepler.lrpage.ebnf.parser.framework.Token;
import bepler.lrpage.ebnf.parser.framework.TokenFactory;
import bepler.lrpage.ebnf.parser.nodes.AlternationToken;
import bepler.lrpage.ebnf.parser.nodes.BangToken;
import bepler.lrpage.ebnf.parser.nodes.ConcatenationToken;
import bepler.lrpage.ebnf.parser.nodes.DefaultKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.DefinitionToken;
import bepler.lrpage.ebnf.parser.nodes.EOFToken;
import bepler.lrpage.ebnf.parser.nodes.EndGroupingToken;
import bepler.lrpage.ebnf.parser.nodes.EndOptionToken;
import bepler.lrpage.ebnf.parser.nodes.EndRepetitionToken;
import bepler.lrpage.ebnf.parser.nodes.ErrorToken;
import bepler.lrpage.ebnf.parser.nodes.IdentifierToken;
import bepler.lrpage.ebnf.parser.nodes.IntToken;
import bepler.lrpage.ebnf.parser.nodes.LeftKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.NameKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.NonKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.PrecKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.PrecedenceKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.PseudonymKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.RightKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.RulesKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.SpecialToken;
import bepler.lrpage.ebnf.parser.nodes.StartBlockToken;
import bepler.lrpage.ebnf.parser.nodes.StartGroupingToken;
import bepler.lrpage.ebnf.parser.nodes.StartOptionToken;
import bepler.lrpage.ebnf.parser.nodes.StartRepetitionToken;
import bepler.lrpage.ebnf.parser.nodes.TerminalStringToken;
import bepler.lrpage.ebnf.parser.nodes.TerminationToken;
import bepler.lrpage.ebnf.parser.nodes.TokensKeywordToken;


/**
 * This class was generated by the LRPaGe parser generator v1.0 using the com.sun.codemodel library.
 * 
 * <P>LRPaGe is available from https://github.com/tbepler/LRPaGe.
 * <P>CodeModel is available from https://codemodel.java.net/.
 * 
 */
public class TokenFactoryImpl
    implements TokenFactory<Visitor>
{

    private final static Pattern[] PATTERNS = new Pattern[] {Pattern.compile("="), Pattern.compile(","), Pattern.compile(";"), Pattern.compile("\\|"), Pattern.compile("\\["), Pattern.compile("\\]"), Pattern.compile("\\{"), Pattern.compile("\\}"), Pattern.compile("\\("), Pattern.compile("\\)"), Pattern.compile("!"), Pattern.compile("#"), Pattern.compile("LEFT"), Pattern.compile("RIGHT"), Pattern.compile("NON"), Pattern.compile("prec"), Pattern.compile("name"), Pattern.compile("default"), Pattern.compile("Precedence"), Pattern.compile("Pseudonyms"), Pattern.compile("Tokens"), Pattern.compile("Rules"), Pattern.compile(":"), Pattern.compile("-?[0-9]+"), Pattern.compile("[a-zA-Z][a-zA-Z0-9_]*"), Pattern.compile("(['\"])(?:\\\\.|(?!\\1).)*\\1"), Pattern.compile("(\\(\\*)((?!\\*\\)).)*\\*\\)"), Pattern.compile("\\s+"), Pattern.compile(".")};

    @Override
    public Token<Visitor> build(int index) {
        switch (index) {
            case  0 :
                return new DefinitionToken();
            case  1 :
                return new ConcatenationToken();
            case  2 :
                return new TerminationToken();
            case  3 :
                return new AlternationToken();
            case  4 :
                return new StartOptionToken();
            case  5 :
                return new EndOptionToken();
            case  6 :
                return new StartRepetitionToken();
            case  7 :
                return new EndRepetitionToken();
            case  8 :
                return new StartGroupingToken();
            case  9 :
                return new EndGroupingToken();
            case  10 :
                return new BangToken();
            case  11 :
                return new SpecialToken();
            case  12 :
                return new LeftKeywordToken();
            case  13 :
                return new RightKeywordToken();
            case  14 :
                return new NonKeywordToken();
            case  15 :
                return new PrecKeywordToken();
            case  16 :
                return new NameKeywordToken();
            case  17 :
                return new DefaultKeywordToken();
            case  18 :
                return new PrecedenceKeywordToken();
            case  19 :
                return new PseudonymKeywordToken();
            case  20 :
                return new TokensKeywordToken();
            case  21 :
                return new RulesKeywordToken();
            case  22 :
                return new StartBlockToken();
            case  23 :
                return new IntToken();
            case  24 :
                return new IdentifierToken();
            case  25 :
                return new TerminalStringToken();
            case  26 :
                return null;
            case  27 :
                return null;
            case  28 :
                return new ErrorToken();
            default:
                throw new RuntimeException("Index out of bounds");
        }
    }

    @Override
    public Token<Visitor> build(int index, String text, int line, int pos) {
        switch (index) {
            case  0 :
                return new DefinitionToken(text, line, pos);
            case  1 :
                return new ConcatenationToken(text, line, pos);
            case  2 :
                return new TerminationToken(text, line, pos);
            case  3 :
                return new AlternationToken(text, line, pos);
            case  4 :
                return new StartOptionToken(text, line, pos);
            case  5 :
                return new EndOptionToken(text, line, pos);
            case  6 :
                return new StartRepetitionToken(text, line, pos);
            case  7 :
                return new EndRepetitionToken(text, line, pos);
            case  8 :
                return new StartGroupingToken(text, line, pos);
            case  9 :
                return new EndGroupingToken(text, line, pos);
            case  10 :
                return new BangToken(text, line, pos);
            case  11 :
                return new SpecialToken(text, line, pos);
            case  12 :
                return new LeftKeywordToken(text, line, pos);
            case  13 :
                return new RightKeywordToken(text, line, pos);
            case  14 :
                return new NonKeywordToken(text, line, pos);
            case  15 :
                return new PrecKeywordToken(text, line, pos);
            case  16 :
                return new NameKeywordToken(text, line, pos);
            case  17 :
                return new DefaultKeywordToken(text, line, pos);
            case  18 :
                return new PrecedenceKeywordToken(text, line, pos);
            case  19 :
                return new PseudonymKeywordToken(text, line, pos);
            case  20 :
                return new TokensKeywordToken(text, line, pos);
            case  21 :
                return new RulesKeywordToken(text, line, pos);
            case  22 :
                return new StartBlockToken(text, line, pos);
            case  23 :
                return new IntToken(text, line, pos);
            case  24 :
                return new IdentifierToken(text, line, pos);
            case  25 :
                return new TerminalStringToken(text, line, pos);
            case  26 :
                return null;
            case  27 :
                return null;
            case  28 :
                return new ErrorToken(text, line, pos);
            default:
                throw new RuntimeException("Index out of bounds");
        }
    }

    @Override
    public Pattern[] getPatterns() {
        return PATTERNS;
    }

    @Override
    public Token<Visitor> getEOFToken(int line, int pos) {
        return new EOFToken(line, pos);
    }

    @Override
    public int size() {
        return  29;
    }

}
