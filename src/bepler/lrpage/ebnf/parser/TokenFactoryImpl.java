
package bepler.lrpage.ebnf.parser;

import java.util.regex.Pattern;
import bepler.lrpage.ebnf.parser.framework.Token;
import bepler.lrpage.ebnf.parser.framework.TokenFactory;
import bepler.lrpage.ebnf.parser.nodes.AlternationToken;
import bepler.lrpage.ebnf.parser.nodes.BangToken;
import bepler.lrpage.ebnf.parser.nodes.ConcatenationToken;
import bepler.lrpage.ebnf.parser.nodes.DefinitionToken;
import bepler.lrpage.ebnf.parser.nodes.EOFToken;
import bepler.lrpage.ebnf.parser.nodes.EndGroupingToken;
import bepler.lrpage.ebnf.parser.nodes.EndOptionToken;
import bepler.lrpage.ebnf.parser.nodes.EndRepetitionToken;
import bepler.lrpage.ebnf.parser.nodes.ErrorToken;
import bepler.lrpage.ebnf.parser.nodes.IdentifierToken;
import bepler.lrpage.ebnf.parser.nodes.IgnoreKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.RulesKeywordToken;
import bepler.lrpage.ebnf.parser.nodes.SpecialToken;
import bepler.lrpage.ebnf.parser.nodes.StartBlockToken;
import bepler.lrpage.ebnf.parser.nodes.StartGroupingToken;
import bepler.lrpage.ebnf.parser.nodes.StartOptionToken;
import bepler.lrpage.ebnf.parser.nodes.StartRepetitionToken;
import bepler.lrpage.ebnf.parser.nodes.TerminalStringToken;
import bepler.lrpage.ebnf.parser.nodes.TerminationToken;
import bepler.lrpage.ebnf.parser.nodes.TokensKeywordToken;


/**
 * This class was generated by the LRPaGe parser generator v1.0 using the com.sun.codemodel library.
 * 
 * <P>LRPaGe is available from https://github.com/tbepler/LRPaGe.
 * <P>CodeModel is available from https://codemodel.java.net/.
 * 
 */
public class TokenFactoryImpl
    implements TokenFactory<Visitor>
{

    private final static Pattern[] PATTERNS = new Pattern[] {Pattern.compile("="), Pattern.compile(","), Pattern.compile(";"), Pattern.compile("\\|"), Pattern.compile("\\["), Pattern.compile("\\]"), Pattern.compile("\\{"), Pattern.compile("\\}"), Pattern.compile("\\("), Pattern.compile("\\)"), Pattern.compile("!"), Pattern.compile("#"), Pattern.compile("Tokens"), Pattern.compile("Ignore"), Pattern.compile("Rules"), Pattern.compile(":"), Pattern.compile("[a-zA-Z][a-zA-Z0-9_]*"), Pattern.compile("(['\"])(?:\\\\.|(?!\\1).)*\\1"), Pattern.compile("\\(\\*.*\\*\\)"), Pattern.compile("\\s+"), Pattern.compile(".")};

    @Override
    public Token<Visitor> build(int index) {
        switch (index) {
            case  0 :
                return new DefinitionToken();
            case  1 :
                return new ConcatenationToken();
            case  2 :
                return new TerminationToken();
            case  3 :
                return new AlternationToken();
            case  4 :
                return new StartOptionToken();
            case  5 :
                return new EndOptionToken();
            case  6 :
                return new StartRepetitionToken();
            case  7 :
                return new EndRepetitionToken();
            case  8 :
                return new StartGroupingToken();
            case  9 :
                return new EndGroupingToken();
            case  10 :
                return new BangToken();
            case  11 :
                return new SpecialToken();
            case  12 :
                return new TokensKeywordToken();
            case  13 :
                return new IgnoreKeywordToken();
            case  14 :
                return new RulesKeywordToken();
            case  15 :
                return new StartBlockToken();
            case  16 :
                return new IdentifierToken();
            case  17 :
                return new TerminalStringToken();
            case  18 :
                return null;
            case  19 :
                return null;
            case  20 :
                return new ErrorToken();
            default:
                throw new RuntimeException("Index out of bounds");
        }
    }

    @Override
    public Token<Visitor> build(int index, String text, int line, int pos) {
        switch (index) {
            case  0 :
                return new DefinitionToken(text, line, pos);
            case  1 :
                return new ConcatenationToken(text, line, pos);
            case  2 :
                return new TerminationToken(text, line, pos);
            case  3 :
                return new AlternationToken(text, line, pos);
            case  4 :
                return new StartOptionToken(text, line, pos);
            case  5 :
                return new EndOptionToken(text, line, pos);
            case  6 :
                return new StartRepetitionToken(text, line, pos);
            case  7 :
                return new EndRepetitionToken(text, line, pos);
            case  8 :
                return new StartGroupingToken(text, line, pos);
            case  9 :
                return new EndGroupingToken(text, line, pos);
            case  10 :
                return new BangToken(text, line, pos);
            case  11 :
                return new SpecialToken(text, line, pos);
            case  12 :
                return new TokensKeywordToken(text, line, pos);
            case  13 :
                return new IgnoreKeywordToken(text, line, pos);
            case  14 :
                return new RulesKeywordToken(text, line, pos);
            case  15 :
                return new StartBlockToken(text, line, pos);
            case  16 :
                return new IdentifierToken(text, line, pos);
            case  17 :
                return new TerminalStringToken(text, line, pos);
            case  18 :
                return null;
            case  19 :
                return null;
            case  20 :
                return new ErrorToken(text, line, pos);
            default:
                throw new RuntimeException("Index out of bounds");
        }
    }

    @Override
    public Pattern[] getPatterns() {
        return PATTERNS;
    }

    @Override
    public Token<Visitor> getEOFToken(int line, int pos) {
        return new EOFToken(line, pos);
    }

    @Override
    public int size() {
        return  21;
    }

}
